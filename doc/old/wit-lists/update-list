The WIT "Update List"

12-12-12

Maintained by: Bob Wittrock

A list of updates to WIT.

/gsa/yktgsa/projects/w/wit/doc/wit-lists/update-list

---------------------------

12-12-12

[CPLEX 12.4]

    WIT now uses CPLEX Version 12.4.

---------------------------

9-21-12

[Windows SDK]

    WIT has been ported to the Windows platform using a combination of the
    Windows SDK (for its compilers, etc.) and MSYS (primarily for its
    unix-like "make" tool). This port replaces our previous Windows ports that
    used Cygwin and MinGW, which are not supported for CPLEX and did not work
    on Windows 64-bit.

    This was needed by anyone who wanted to use WIT on a new machine running
    Windows, since they are all 64-bit now.

---------------------------

7-13-12

[pip to operations]

    The post-implosion pegging technique has been extended to allow pegging to
    operations. It provides an answer to the question: "Which resources were
    used to enable a particular operation to be executed in a particular
    period?" It applies to all the usual pegging attributes:

      supplyVol
      execVol
      subVol
      prodVol
      consVol
      coExecVol
      sideVol

    This was critically needed for SCE's contribution to the Demand Shaping
    project, allowing the approach to be applied to the "building blocks" of
    the IBM hardware product structure rather than the end product demands.

    Also, there has been a recurring need for this capability in SCE's
    applications.

---------------------------

5-22-12

[nPeriods warning]

    Added a warning message if a part or operation is created when nPeriods has
    not been explicitly set.

---------------------------

11-30-11

[demand exists]

    Added the API function witGetDemandExists, which allows the application
    program to determine whether or not a specified demand exists in a WitRun.

---------------------------

10-26-11

[optional release spec]

    In the input data file format, the release specification is now optional and
    is not used for anything. Also, if a release specification is given, it is
    allowed to be any string. The file written by witWriteData does not have a
    release specification.

---------------------------

8-30-11

[release 8.0]

    The release number for WIT is now 8.0.

---------------------------

8-30-11

[COIN removal]

    The option of using solvers from COIN-OR to solve the LP/MIP in WIT has been
    removed.

---------------------------

2-15-11

[CPLEX solution info]

    Added four new global output attributes that provide information about the
    solution state of CPLEX:

    * cplexStatusCode (type int): This is the CPLEX solution status code for the
      most recent call to a CPLEX solve routine, if any.

    * cplexStatusText (type string): This is the CPLEX solution status text
      for the most recent call to a CPLEX solve routine, if any.

    * cplexMipBound (type float): When the CPLEX MIP solver has been invoked,
      cplexMipBound is the tightest upper bound that it found on the optimal
      objective function value.

    * cplexMipRelGap (type float): When the CPLEX MIP solver has been invoked,
      cplexMipRelGap is the relative gap between the objective function value of
      the solution and the tightest upper bound that it found on the optimal
      objective function value.

    These attributes are intended for use in conjunction with CPLEX parameter
    specifications: Since some CPLEX parameters can cause the CPLEX solve
    routines to terminate early, it may be helpful for the application program
    to check the CPLEX solution status code from the solve and display the
    CPLEX solution status text and/or its objective function bound, using these
    attributes.

---------------------------

2-7-11

[CPLEX parameter specifications]

    Added a means for the application program to specify values for the
    parameters of CPLEX, which, in turn, allow the behavior of CPLEX to be
    customized.

    This allows CPLEX to be used from WIT in more advanced ways, which can be
    particularly helpful for solving optimizing implosion problems with
    integrality. For example, the application program can now specify a CPU time
    limit or a relative optimality gap for a CPLEX MIP solve.

---------------------------

1-6-11

[integrality attributes without MIP mode]

    The attributes intExecVols, intSubVols, and intShipVols are now allowed to
    be TRUE when mipMode is FALSE. When mipMode is FALSE, these attributes are
    ignored. (This allows an application program to easily switch between a MIP
    problem and its LP relaxation.)

---------------------------

12-27-10

[CPLEX: Port to zLinux]

   Ported WIT with CPLEX to zLinux.

---------------------------

12-16-10

[CPLEX: Port to Cygwin]

   Ported WIT with CPLEX to Windows using Cygwin.

---------------------------

12-13-10

[CPLEX: Multiple Objectives]

   Added the ability to perform multiple-objectives optimizing implosion with
   CPLEX as the selected solver.

---------------------------

12-3-10

[CPLEX: MinGW, MIP Mode, Stochastic Implosion]

   Ported WIT with CPLEX to Windows using MinGW.
   Added the ability to perform optimizing implosion in MIP mode with CPLEX as
   the selected solver.
   Added the ability to perform stochastic implosion with CPLEX as the selected
   solver.

---------------------------

11-12-10

[accelerated optimizing implosion with CPLEX]

   Added the ability to perform accelerated optimizing implosion with CPLEX as
   the selected solver.

---------------------------

10-21-10

[optimization with CPLEX, initial release]

    Added the ability to optionally embed CPLEX into WIT, and then, optionally
    to use it as the solver of the LP problem for optimizing implosion. This
    initial release implements the following subset of WIT's optimization
    capability in CPLEX:

    * Ordinary optimizing implosion
    * Available on Linux
    * Ported to AIX 32 bit
    * Ported to AIX 64 bit
    * Accessible from WIT-J
    
    The following capabilities are planned for future releases:

    * Ported to MinGW
    * Ported to Cygwin
    * Accelerated optimizing implosion
    * MIP mode
    * Multiple objectives mode
    * Stochastic implosion
    * Set/get access to a relevant subset of the CPLEX parameters

---------------------------

10-1-10

[modifiable heuristic allocation]

    Added a capability that allows a sophisticated application program to make
    feasible modifications to the implosion solution during the course of
    heuristic allocation, without deactivating it.

    This item was needed for the GIView/Planner engagement with Panasonic,
    to be used in place an approach that involved repeatly shutting down and
    restarting heuristic allocation in userHeurStart mode, which was resulting
    in unacceptable CPU time performance.

---------------------------

8-16-10

[lead time bounds]

    This capability applies to heuristic implosion and allocation. It allows an
    upper bound to be imposed on the time interval between the period in which a
    part is produced in order to enable a shipment and the period of the
    shipment.

    This item was needed for the GIView engagement with Panasonic, replacing
    i2/SCP with GIView/planner.

---------------------------

8-6-10

[selection recovery]

    Many of the advanced aspects of the heuristic are examples of a general
    technique, called "selection":

    * Multi-Route
    * Build-Ahead
    * Multi-Exec
    * Proportionate Routing
    * Stock Reallocation

    The selection techniques involve selecting among alternative ways to
    meet an internal requirement.

    One aspect of the selection techniques that makes them run reasonably fast
    is a technique that we may call "selection discarding". This means that
    when a failure to meet a requirement is due to a particular selection, the
    selection is discarded and not used again. For example, if NSTN build-ahead
    is trying to meet a requirement by building ahead part A in period 7 and
    finds that it cannot build any more of part A in period 7, it switches to
    period 6 and never returns to period 7.

    While the selection discarding technique has historically been very
    effective, it is theoretically possible for it to cause the heuristic to
    miss opportunities to meet requirements, thereby causing it to compute a
    poor quality solution. This would be especially likely to happen if the
    "lead time bounds" capability is used, because an attempt to build a part
    in a period that failed for one demand could succeed for a different demand.

    The selection capability solves this problem: A global boolean
    attribute, selectionRecovery, would be added. When this attribute is TRUE,
    selection recovery is in effect: At the end of each allocation increment
    (i.e., call to witIncHeurAlloc, or its internal equivalent), all discarded
    selections would be recovered. The drawback of using this capability is that
    it significantly increases the run time of the heuristic.

    This item was needed in order to be used in conjunction with the lead time
    bounds capability for the GIView engagement with Panasonic, replacing i2/SCP
    with GIView/planner.

---------------------------

4-2-10

[multiple objectives mode]

    Added a new capability to optimizing implosion: "multiple objectives mode". 
    This capability allows more than one objective function to be specified and
    causes optimizing implosion to find an implosion solution that jointly
    maximizes all of the objective functions, treated as a strict hierarchy.

---------------------------

12-8-08

[access file mode]

    Changed the default value of mesgFileAccessMode from "a" to "w".
    This is the value that most WIT application programmers seemed to be using.

---------------------------

3-5-08

[stage by period]

    In stochastic implosion, created an option to allow the stage of an item of
    input data to be determined by the period with which the data is associated
    instead of the object with which it is associated; e.g., demandVol would
    belong to stage 0 in early periods and to stage 1 in later periods.
    This is the more usual way of specifying stages in a stochastic programming
    problem.

---------------------------

2-26-08

[object name change]

    Added API functions to allow the application program to change the names of
    existing parts, demands, and operations.

    This capability was needed to facilitate the complex construction of the WIT
    model used in ESO2.

---------------------------

1-2-08

[stochastic implosion, release 4]

    witStochImplode may now be invoked when there are BOM entries and
    substitutes connecting operations in stage 0 to parts in stage 1.

    This will enable, e.g., models in which one must commit to a shipment plan
    while the supply line is uncertain.

---------------------------

12-27-07

[stochastic implosion, release 3]

    Enabled PIP for stochastic implosion.

    Since most implosion applications also use pegging in an essential way, it
    seems likely that applications of stochastic implosion will need pegging as
    well.

---------------------------

12-21-07

[stochastic implosion, release 2]

    Added the following to stochastic implosion:

    * The following attributes were made scenario-specific:

      * scrapCost     (part)
      * stockCost     (part)
      * shipReward    (demand)
      * cumShipReward (demand)
      * execCost      (operation)
      * subCost       (substitute)

    * witSetCurScenarioIndex now runs fast enough that an application program no
      longer needs to enter its scenario-specific data in "scenario-major"
      order in order to avoid incurring excessive CPU time. Any order can be
      used. (Scenario-major order is still important to use when extracting
      scenario-specific solution data. For details, see the WIT Guide.)

    * Stochastic implosion may now be invoked when wit34Compatible is TRUE.
      This will facilitate use by SCE-based applications.

---------------------------

11-1-07

[witGetExpCycle]

    Added a new API function, witGetExpCycle, that searches for explodeable
    cycles in the complete BOM structure and retrieves one of them, if there are
    any. It does this without issuing an error message for the cycle.

    Needed for ESO2 to allow the application program to automatically remove
    explodeable cycles in an application-specific way.

---------------------------

10-25-07

[stochastic implosion]

    Added a new capability that formulates and solves a stochastic version of
    the optimizing implosion problem, called the "stochastic implosion problem".
    This problem is an implosion-specific version of the standard
    "stochastic linear programming with two stages and multiple scenarios"
    formulation. The implosion data model has been extended to multiple
    scenarios in a compact way and a new multi-scenario LP formulation has been
    implemented.

    This initial release includes the following features:

       * Stage By Object: The stage of each data attribute (stage 0 or stage 1)
         is determined by the object (i.e., part, operation, or demand) with
         which it is associated.

       * The following input data attributes are treated as "scenario-specific"
         (i.e., a potentially different value of each scenario):
         * supplyVol
         * demandVol
         * execBounds
         * stockBounds
         * cumShipBounds

       * A stochastic implosion problem can be specified either by explicit API
         function calls or through a WIT data file.

    There is currently no known specific customer need or project need for this
    new capability; however on repeated occasions, we have seen projects that
    could have benefited from a stochastic implosion capability if it had
    already existed. The purpose of implementing this capability was in
    anticipation of any such projects that may arise in the future.

---------------------------

7-19-07

[ASAP pegging order]

    PIP's "pegging order" is the order in which it pegs the supplies,
    production, and side-effects of a material part, considered over all
    periods. By default, PIP uses the NSTN (No-Sooner-Than-Necessary) pegging
    order, which can be described as follows:

    * First, the supply of the part is pegged in periods nPeriods-1, ..., 1, 0.
    * Next, the production of the part is pegged in periods 
      nPeriods-1, ..., 1, 0.
    * Lastly, the sideVol for the part is pegged in periods
      nPeriods-1, ..., 1, 0.

    This item introduced the ASAP (As-Soon-As-Possible) pegging order, which can
    be described as follows:

    * First, the supply of the part is pegged in periods 0, 1, ..., nPeriods-1.
    * Next, the production of the part is pegged in periods
      0, 1, ..., nPeriods-1.
    * Lastly, the sideVol for the part is pegged in periods
      0, 1, ..., nPeriods-1.

    This capability was needed for Scorpio's engagement with Kawasaki Heavy
    Industries, but may be useful in general: the peggings that result seem more
    "orderly" than those produced by the NSTN pegging order.

---------------------------

3-9-07

[disallowing scrap]

   Added a boolean attribute to parts: scrapAllowed, default value: TRUE.
   When this attribute is FALSE for a part, scrapping of the part is disallowed
   in optimizing implosion. (scrapVol = 0) This attribute applies only to
   optimizing implosion, not to heuristic implosion.
   
   This capability was needed for the DCX project to reduce the size of the
   resulting (stochastic) LP model.

---------------------------

3-8-07

[disallowing late shipment]

   Added a boolean attribute to demands: shipLateAllowed, default value: TRUE.
   When this attribute is FALSE for a demand, late shipments are disallowed for
   the demand: All shipments that are done for the demand must be done in the
   period in which the demandVol occurred. This constraint applies in both
   heuristic and optimizing implosion.
   
   This capability was needed for the DCX project to reduce the size of the
   resulting (stochastic) LP model.

---------------------------

1-26-07

[witCopy<Object>Data]

   Added six new API functions for copying the input data attributes from one
   data object into another data object of the same type:

      witCopyPartData
      witCopyDemandData
      witCopyOperationData
      witCopyBomEntryData
      witCopySubsBomEntryData
      witCopyBopEntryData

   In each case, the function takes arguments that specify two objects (e.g.,
   two parts): the original object and the duplicate object. The function copies
   the input data attributes from the original object into the duplicate object.
   The original and duplicate objects may be in the same WitRun or in two
   different WitRuns.

---------------------------

1-5-07

[external optimizing implosion]

   Added the following experimental new capability to optimizing implosion:
   Normally optimizing implosion involves a "solve" step in which WIT makes
   calls to solvers from COIN-OR to solve the LP/MIP formulation of the
   optimizing implosion problem. In external optimizing implosion, this "solve"
   step is performed by the application program: The application program
   extracts the LP/MIP problem from WIT, invokes its own solver to solve the
   LP/MIP problem and then loads the solution to the LP/MIP problem back into
   WIT. The external optimizing implosion capability consists of a set of API
   functions to perform the following tasks:

   * Control the state of the external optimizing implosion process.
   * Extract the LP/MIP problem.
   * Load in the solution to the LP/MIP problem.
   * Determine the column or row index of each variable or constraint in the
     LP/MIP problem, specified in terms of the objects of the implosion problem
     (parts, operations, etc.).

---------------------------

12-12-06

[mip mode]

   Added a new a capability to optimizing implosion: MIP mode, which causes
   optimizing implosion to be solved as a Mixed Integer Programming (MIP)
   problem.

   There are four new attributes for this capability (all boolean):
       mipMode (global)
       intExecVols (operation)
       intSubVols (substitute)
       intShipVols (demand)

   When mipMode is TRUE, optimizing implosion is solved as a MIP problem. When
   the intExecVols attribute for an operation is TRUE, optimizing implosion will
   constrain the execVol of the operation in all periods to take on integer
   values only. intSubVols and intShipVols are interpreted similarly.

   MIP mode is an experimental aspect of WIT and should be used with caution:
   The resulting MIP problem may take vastly longer to solve than the
   corresponding LP problem without integrality constraints.

---------------------------

9-28-06

[heuristic search increment]

    A new float attribute for demands has been added: "searchInc". When the
    heuristic attempts to meet a demand at less than the requested amount, it
    will only consider amounts that are multiples of searchInc ("search
    increment") for the demand. Default Value: 1.0.

    Needed for some of the SCE Pandemic models.

---------------------------

9-8-06

[alternative residualVol and excessVol computation]

    Added two global boolean attributes: nstnResidual and minimalExcess.

    When nstnResidual is TRUE, each part's residualVol is computed on a
    "no sooner than necessary" basis: the residual volumes occur in the latest
    possible periods. When it is FALSE, each part's residualVol is computed on
    an "as soon as possible" basis: the residual volumes occur in the earliest
    possible periods. (FALSE by default).

    When minimalExcess is TRUE, each part's excessVol (in each period) is
    computed as the minimum portion of the part's residualVol that must be
    attributed to supply. When it is FALSE, the excessVol is computed as the
    maximum portion of the part's residualVol that can be attributed to supply.
    (FALSE by default).

    This capability was needed for Scorpio for Renesas and possibly other
    Scorpio customers. Renesas users would prefer to see the earliest supplies
    and production consumed and would prefer to see supplies consumed rather
    than current production 

---------------------------

8-9-06

[execVol pegging for BOP entries]

    Added a new pegged quantity to PIP: "coExecVol" (co-execution volume) for
    BOP entries. For any BOP entry of an operation, any execution period, any
    demand, and any shipment period, the corresponding pegged coExecVol is the
    portion of the execVol of the operation in the execution period that's
    pegged to the demand in the shipment period and whose pegging is
    specifically associated with the BOP entry.

    This capability was needed in order to make the output of PIP more
    understandable and more complete in problems with operations that have
    multiple explodeable BOP entries. There was a specific need in the ESO2
    application.

---------------------------

8-3-06

[Removal of IPIP]

   Removed individual post-implosion pegging (IPIP).
   Group post-implosion pegging (GPIP) is now simply called
   "post-implosion pegging" (PIP).

---------------------------

6-14-06

[new PIP pegging order]

    Revised the order in which the explosion process of PIP (both IPIP and GPIP)
    selects among the alternative ways of fulfilling a requirement on a material
    part so as to achieve the following effect:

    * First, the supply     of the part is used in all periods (last to first).
    * Next,  the production of the part is used in all periods (last to first).
    * Last,  the sideVol   for the part is used in all periods (last to first).

    Critically needed by SCE for its Server Group deployment for their new
    "prioritized explosion" application.

---------------------------

5-2-06

[opt with COIN]

    Changed WIT to use software from the COIN-OR project to solve its
    optimization problem instead of OSL. The following components of
    COIN are used: CLP, OSI, and CBC.

    This change was necessitated by that fact that IBM has generally withdrawn
    support for OSL.

    Also, the use COIN software in WIT constitutes multiple industrial
    applications of the COIN software and this is expected to be valuable to the
    COIN-OR project at this stage in its development.

---------------------------

3-29-06

[group post-implosion pegging]

    Provided a post-implosion style pegging capability that handles operations
    with multiple explodeable outputs in a way that treats each output as 100%
    pegged production and not side-effect. This required an expansion of
    the concept of a pegging so that, e.g., each unit of execVol of an operation
    could be pegged to more than one shipment, reflecting that its resources are
    being shared. Unexplodeable output (i.e., expAllowed = false) is still
    treated as side-effect.

    This feature is critical for ESO/2. It would also be useful for Scorpio for
    binning and down-grading in its ELPIDA application. Other Scorpio
    semiconductor customers may need it later.

---------------------------

11-4-05

[error recovery]

    API functions can now be called after WIT has issued a severe or fatal
    error message, subject to some restrictions.

    This should make it easier to implement WIT application programs 
    in an application server environment such as Websphere.

---------------------------

10-13-05

[multi-thread]

    The API can now be used in a multiply-threaded environment such as Java.
    Specifically, overlapping API function calls (i.e., those where one
    function call is initiated before the previous one is concluded) are now
    allowed, subject to certain restrictions.

    This is intended to make it easier to implement WIT application programs 
    in an application server environment such as Websphere.

---------------------------

7-15-05

[exceptions]

    Enabled WIT optionally to throw a C++ exception when it issues a severe or
    fatal error message. 

    The intention of this feature is to make it easier to develop and reliably
    maintain WIT application programs that must keep the program process running
    even when WIT encounters an error. This is the case with RCP and we may have
    more such applications in the future, particularly if the application must
    operate in an application server environment such as Websphere. With this
    new capability, instead of checking the return code of each call to a WIT
    API function, you simply place all of the code that calls WIT API functions
    inside a single try block and write a single catch block to handle the
    exception that WIT might throw.

---------------------------

6-17-05

[new treatment of pipShare]

    Previously, when an operation had more than one explodeable BOP entry,
    the PIP algorithm would use the pipShare attribute to determine how much of
    the production of each BOP entry was peggable and how much was considered to
    be side-effect. The users of PIP found this model confusing. The pipShare
    logic has now been changed. In the new treatment, if an operation has
    multiple explodeable BOP entries, the pegged execVol for the operation is
    allocated among its explodeable BOP entries in proportion to their
    pipShares. Explodeable BOP entries do not generate sideVol.

---------------------------

6-13-05

[removal of objective #2 from documented version of WIT]

   The following changes were made:

   * The default value of objChoice was changed from 2 to 1.
   
   * Documentation of the objChoice attribute was removed from the WIT Guide,
     but the attribute still works as before.

   * Documentation of objective #2 was removed from the WIT Guide, but the
     attributes and API functions for it still work as before.

   * The names of the attributes for objective #1 were changed to reflect the
     fact that there is only one objective function, but the old names of the
     attributes and API functions still work as before.

---------------------------

6-2-05

[removal of documentation for opt with lot sizes]

   The optimizing implosion with lot sizes capability and the optWithLotSizes
   attribute have been made into undocumented aspects of WIT.

---------------------------

3-21-05

[removal of objChoice restrictions]

   Objective #1 attributes, such as obj1ScrapCost, can now be set and retrieved
   even if objChoice != 1.

   objChoice can now be set even when parts and/or operations exist.

---------------------------

3-18-05

[PIP avoiding excessVol]

    Revised the logic of PIP.

    Before the revision:
       For each part in each period:
          The sum of all pegged supplyVols <= supplyVol

    After the revision:
       For each part in each period:
          The sum of all pegged supplyVols <= supplyVol - excessVol

---------------------------

3-16-05

[vector propRouting attribute]

    Replaced the scalar propRouting attribute with a vector attribute propRtg.

    This was needed by Scorpio for Renesas and Cassio.

---------------------------

2-8-05

[pegged critical list]

    The new "pegged critical list" is similar to the critical parts list, but
    with the following differences:
    * It only applies to heuristic implosion and allocation.
    * Each critical part and period is associated with the shipment that was
      blocked by it.

    Needed by SCE for its Server Group application.

---------------------------

1-24-05

[tie breaking proportionate routing]

    In the previous implementation, when propRouting and penExec were both used
    in the same problem, propRouting override would penExec, wherever it was
    turned on. The [tie breaking proportionate routing] item adds an option to
    essentially reverse this behavior. This new capability is invoked by setting
    a new global boolean attribute, tieBreakPropRt, to TRUE.

    When tieBreakPropRt is TRUE, at any part with propRouting = TRUE, 
    if there is more than one BOP entry producing the part such that producing
    through the BOP entry incurs the (heuristic) minimum penalty, then all such
    BOP entries are used in proportion to their routingShares. In this way,
    propRouting is used to break ties for the minimum execution penalty.

    The same logic applies to propRouting at a BOM entry in a penExec
    context.

    This capability was needed by Scorpio for Renesas.

---------------------------

5-19-04

[post-implosion pegging, forth release]

    Extended PIP to apply to problems containing operations with multiple
    explodeable BOP entries.

    This was needed to allow PIP to be used by ESO/2, whose customer has been
    requesting pegging information.

---------------------------

4-19-04

[double precision]

    Allows the application program to interact with WIT using double-precision
    API function arguments (i.e. doubles) instead of single-precision arguments
    (i.e. floats):

    * All values in WIT that are nominally of type "float" or "vector of floats"
      are now stored internally as type "double" or "vector of doubles. This
      was done is a way that did not increase WIT's memory usage in large-scale
      tests with real data.

    * For each pre-existing API function that has at least one argument whose
      type involves "float", there is now a second API function whose
      corresponding argument(s) involve "double". In each case, the "double"
      version of the function has the same name as the "float" version, but
      with the letters "Dbl" appended to the end of the name. The two functions
      perform the same essential task, but the float version must do type
      conversion between the float arguments and the double internal values,
      while the double precision version does no type conversion.

      Example: witSetPartSupplyVolDbl

      Number of new API functions: 136.

    * witReadData now reads in the input data in double precision.

    * witWriteData now writes out the input data in double precision.
      There is a new global boolean attribute highPrecisionWD. When FALSE
      (default), witWriteData uses the same moderate precision format for
      writing out floats that it did before this update: the "%g" format. When
      highPrecisionWD is TRUE, witWriteData uses a higher precision format
      for writing out floats: the "%.14g" format.

    This feature is needed by Scorpio for cases in which the input data is
    precise to a greater degree than can be represented in single precision,
    e.g., demandVol > 100,000,000. It is critically needed for Scorpio's Renesas
    engagement.

---------------------------

1-23-04

[post-implosion pegging, third release]

    Extended PIP to apply to solutions generated by optimizing implosion or
    user-input.

    This is a very high priority item for SCE's Available-To-Sell application:
    Up to now, ATS has been using opt implosion and then regenerating its
    solution with the heuristic and applying either concurrent pegging or PIP. 
    But recently, the ATS model has become too complex for this approach to work
    and so the ability to peg an opt implosion solution directly is now
    critical.

---------------------------

12-5-03

[post-implosion pegging, second release]

    Extended PIP to apply to problems with Unexplodeable BOP entries and BOM
    entries with negative consRates.

    This is a very high priority item for SCE's Server Group deployment; see
    below.

---------------------------

11-3-03

[post-implosion pegging, initial release]

    Provided a new version of pegging, that can be used in place of the old
    version. The new version differs from the current version in the following
    ways:

    * It is applied after the implosion solution was computed.

    * The new pegging is not be a reflection of the way in which the implosion
      solution was originally computed.

    * It only works on problems that satisfy certain restrictions, e.g., No
      operation may have > 1 BOP entry.

    * It ignores lot-sizes.

    * The new pegging is designed to be physically meaningful.
      Specifically, the existing implosion solution will be re-constructed
      for pegging purposes by an explosion process, and the pegging will reflect
      that explosion. Thus each resource pegged to a demand will actually have
      been used by that demand in the re-constructed solution. Consequently, the
      new pegging will have a natural, physical interpretation, even if, e.g.,
      the solution was originally computed by the heuristic using stock
      reallocation.

    * The following attributes are pegged:

      * operation.execVol
      * subEntry.subVol
      * part.supplyVol
      * part.prodVol
      * part.consVol

    This is a very high priority item for SCE's Server Group deployment:

    * To keep SCE's current pegging applications meaningful with stock
      reallocation.
    * To peg supplyVol.
    * To facilitate an "iterative implosion" application.

---------------------------

8-5-03

[vector routingShare]

    Changed the type of the routingShare attribute for BOP entries, BOM entries,
    and substitutes from float to vector of floats.

    Requested by a customer of SCORPIO who will be using Proportionate Routing.

---------------------------

5-8-03

[proportionate routing]

    A new optional capability has been added to heuristic implosion and
    allocation, called "proportionate routing". The proportionate routing
    technique applies to the same cases as the multiple routes technique.
    However, instead of using one BOP entry at a time to produce a given part,
    the proportionate routing technique uses all of the BOP entries for the
    part at the same time, initially, according to fixed ratios specified by
    the user. If a BOP entry runs into a constraint that prevents it from
    producing more of the part, that BOP entry is allowed to drop out and the
    proportionate routing is applied only to the BOP entries that remain active.
    The same technique applies to the use of substitutes for a BOM entry.

    This was needed by SCE for a least the following three applications, all
    needed by the IBM Server Group deployment:

    * Feature Set Planning
    * Proportionate Multiple Sourcing
    * Product Mix Planning (Here, demand is known reasonably well for a family
      of products, but the fraction of a family's demand for each individual
      product is only a guess.)

---------------------------

Apr. 03

[64-bit opt implode]

    Made optimizing implosion work on a 64-bit platform using OSL V.3. Needed by
    SCORPIO, to allow optimizing implosion to solve much larger problems. 
    (> 2 Gig). As of Apr. 03, this has been done on AIX V.4. A port to AIX V.5
    can be done, if needed.

---------------------------

1-24-03

[witShutDownHeurAlloc]

    A new API function, witShutDownHeurAlloc, has been added. Its effect is
    similar to witFinishHeurAlloc, except that it does not invoke 
    post-processing. Thus is it faster in CPU time than witFinishHeurAlloc and
    may be more appropriate to use than witFinishHeurAlloc when the
    application is interrupting heuristic allocation repeatedly in a
    "user-specified heuristic starting solution" setting.

---------------------------

12-31-02

[exec penalties on BOM entries and subs]

    A new attribute, execPenalty, has been added to BOM entries and substitutes.
    This attribute is used in penalized execution in the same way as the
    operation execPenalty attribute.

    This was needed so as to make it easier for SCE to use penalized execution
    in order to implement the complex multi-level substitution logic of its
    "sharing" model.

---------------------------

12-27-02

[user-specified heuristic starting solution]

    When this feature is used, the heuristic uses a user-specified solution as
    its initial solution. It then proceeds from there, subject to the following
    constraint: For each operation, substitute and demand, the execVol, subVol
    and shipVol that it computes will each be >= the corresponding execVol, 
    subVol and shipVol in the user-specified solution. The user-specified
    solution is required to be feasible.

    This capability can be used to achieve the effect of altering the implosion
    problem part-way through the heuristic allocation process, by employing the
    following procedure:

    * Run heuristic allocation until some change is needed in the input data.
    * Stop and modify the problem as needed (e.g., by changing supplyVols,
      demandVols, adding or deleting parts or BOM entries, etc.).
    * Make corresponding modifications to the solution, if necessary to keep it
      feasible.
    * Restart heuristic allocation and continue where it left off.

    This feature was needed by SCE, in order to implement a "dynamically
    customized complex order" capability. In general, I think its potential for
    application is quite powerful.

---------------------------

12-17-02

[single-source with a new algorithm]

    Re-implemented single-source with a new algorithm, which improves the
    solutions computed by single-source in many cases and is generally a more
    robust design.
    
---------------------------

10-10-02

[2-level lot sizes]

    Allows operations to have 2 sets of min and inc lot sizes: a smaller set and
    a larger set. Which set of lot sizes to apply is determined by a 
    threshold.

    Needed for SCORPIO's distribution module, to handle alternate modes of
    transport (e.g., truck vs. train, etc.).

---------------------------

9-13-02

[opt implosion with lot-sizes]
    
    Allows optimizing implosion to respect minLotSize and incLotSize, by using
    Mixed Integer Programming.

    This is a very natural extension that we've wished we had, many times over
    the years, but it's becoming more important now for service-oriented
    applications.

    Unfortunately, for many implosion problems, running opt implosion with 
    lot-sizes results in such a drastic increase in CPU as to be prohibitive.
    However, as of this writing, it is already being used effectively in an 
    application for a real customer. So it all depends on the application.

---------------------------

8-20-02

[OSL Version 3]

    Updated optimizing implosion to use the new version of OSL, V.3. This has
    the following benefits:

    * Faster solutions.
    * Reduced memory usage.
    * The OSL group had discontinued for V.2 some time ago.
    * It's a necessary pre-requisite for using anything new in OSL.
      
---------------------------

7-26-02

[single-source]

    The single-source technique is controlled by the singleSource boolean input
    attribute for parts and BOM entries. When singleSource is TRUE for a part,
    the multi-route algorithm attempts to ship the entire desIncVol specified by
    witIncHeurAlloc (or its equivalent in heuristic implosion) by using only one
    BOP entry to fill the requirements for that part. This is called 
    "single-source" mode. The same BOP entry is used in all periods. If the 
    heuristic fails to find a way to ship the entire desIncVol subject to this
    constraint, it then proceeds in "multi-source" mode for this part, using as 
    many BOP entries for the part as needed. When singleSource is TRUE for a BOM
    entry, a similar logic is applied to its substitutes.

    This feature was needed by SCORPIO for its ATP module. The SCORPIO team 
    considers this to be a desirable feature for potentially all of their
    customers. Single-source routings are simpler to implement and can decrease
    transportation costs and setup costs.

---------------------------

4-29-02

[object iteration]

    Added a collection of API functions that enable the application program to
    iterate through the set of all object in a WitRun in the order in which they
    were created.
    
    This capability should be of value WIT users in two ways: If one is
    building some kind of application that needs to create a duplicate of a
    WitRun without using witCopyData or witWriteData and witReadData, the
    iteration capability (or something like it) is essential: The current code
    provides no way to list the objects in the order of creation. If one were
    to try to duplicate a WitRun without duplicating the object creation order,
    the resulting WitRun would not be truly equivalent to the original. This
    issue arose in a project at Yorktown which created an XML format to
    represent (the input state of) a WitRun. Without object iteration, the
    representation was necessarily imperfect.

    Object iteration can also be useful in the following way: many application
    programs need to iterate through all or some of the data objects of a
    WitRun, without any particular concern about the order. Without object
    iteration, the application program must use a different set of API functions
    to iterate through the objects of each class. Object iteration allows the
    application to iterate through any subset of objects as required, using a
    single uniform "while" loop.

---------------------------

4-16-02

[selection splitting for penalized execution]

    Extended selection splitting to apply to penalized execution. This enables
    penalized execution to use more than one BOP entry in order to build a part
    in a period, and more than one substitute for a BOM entry in a period, 
    corresponding to one unit of top-level demand.
   
---------------------------

12-20-01

[selection splitting for multi-route]

    Extended selection splitting to apply to multi-route. This enables
    multi-route to use more than one BOP entry in order to build a part in a
    period, and more than one substitute for a BOM entry in a period, 
    corresponding to one unit of top-level demand.
   
---------------------------

12-17-01

[selection splitting for selective stock reallocation]

    Extended selection splitting to apply to the selective stock reallocation
    feature. This allows requirements on a part in a single period,
    corresponding to one unit of top-level demand, to be met partially with and
    partially without stock reallocation.

---------------------------

10-8-01

[selective stock reallocation]

    In the original implementation of stock reallocation, if the heuristic
    performed a stock reallocation and then it turned out that the part could
    not be built in the later period after all, due to constraints below the
    operation that produces the part, then the part would not be built in the
    required period either, and the requirement would not be met.

    This problem could be remedied by using build-ahead on the part:
    If the part could not be built in the later period, build-ahead could
    simply move the requirement back to its original period. Unfortunately,
    this remedy would not always work, if there were a build-ahead upper bound,
    because the upper bound could prevent build-ahead from moving the
    requirement back to the original period.

    The purpose of [selective stock reallocation] is to remedy this problem 
    in cases when build-ahead is not acceptable, or when there is a build-ahead
    upper bound. In the scenario described above, [selective stock reallocation]
    allows the heuristic to build in the required period, when building in
    the later period fails.

    Needed by SCORPIO, for applications involving build-ahead upper bounds.

---------------------------

8-30-01

[shadow prices]

   At the user's request, optimizing implosion now computes shadow prices for
   the supplyVols of parts.

   Needed for a research project on Supply Chain Risk Management being conducted
   by members of the E-Commerce and Math Sciences Depts. Also needed for an
   Available-To-Sell tool being developed by the Server Group.

---------------------------

8-20-01

[selection splitting speed-up]

   Made selection splitting run faster. The CPU time for heuristic implosion was
   reduced by 56% in the largest test case.

---------------------------

8-6-01

[pegging]

   A new optional capability has been added to heuristic implosion and
   allocation, called "pegging". This feature keeps track of the association
   between the resources that are being allocated by heuristic implosion and
   allocation and the demands for which they are being allocated and then 
   provides this information to the application program. This feature is
   controlled by a new global input attribute, "perfPegging". New API functions
   are:

      witSetPerfPegging
      witGetPerfPegging
      witGetDemandExecVolPegging
      witGetDemandSubVolPegging
      witClearPegging 

    Needed by SCE in order to do pegging for the IBM server group deployment.
    
---------------------------

6-4-01

[selection splitting for multi-exec]

    Extended selection splitting to apply to the multiple execution periods
    technique.

---------------------------

5-18-01

[selection splitting for build-ahead]

    Currently the "selection" techniques of heuristic implosion / allocation
    (multi-route, NSTN/ASAP build-ahead, multi-exec periods) share the following
    property: If there are lot-sizes in the problem, the requirements generated
    by a "lot" must all be met on the same "selection" (i.e., the same routing,
    the same set of build-ahead periods, etc.). The [selection splitting] 
    feature would allow the requirements generated by a "lot" to be split across
    multiple selections. 

    This capability would also apply to "lots" formed as a result of usage 
    rates and yields, rather than actual lot sizes. E.g., if an external demand
    1 unit of a final product expanded (via usage rates and yields) to an 
    internal demand 100 units of some subassembly, the selection techniques 
    would (currently) treat this 100 units as indivisible, while the proposed 
    [selection splitting] technique would split it into smaller units.

    Needed by the new Scorpio DtP (distribution planning) module, and the Global
    Supply Chain Planning module.

    Also, I think this would be a valuable feature to add to WIT for general
    purposes, in order to make the multi-route, NSTN/ASAP build-ahead, and
    multi-exec periods features more accurate and robust.

    This is a very major effort: The technique I've designed is quite
    sophisticated and alters the way selection is performed at very deep level
    of the algorithm.

    On 5-18-01, a first version of selection splitting completed. It applies to
    build-ahead only.

---------------------------

10-20-00

[stock bounds]
    Made heuristic implosion respect soft lower bounds on stockVols.
    Satisfying these bounds is viewed as less important than meeting
    demands. A global boolean determines whether or not the stock bounds
    on higher level parts would take precedence over those on lower level parts.

    Needed for SCORPIO for DtP and for Sony's use of PP.

---------------------------

7-25-00

[vector usageRates]
    Replaced the following 3 scalar attributes with vector attributes, while
    maintaining upward compatibility:

       Object Type   Scalar Attr   Vector Attr
       -----------   -----------   -----------
       BOM entry     usageRate     consRate
       substitute    usageRate     consRate
       BOP entry     prodRate      productRate

    Needed for SCE for PSG, server group, research projects, and simplifying
    old SCE code.

---------------------------

5-8-00

[stock reallocation]
    
    Consider the following scenario: In heuristic implosion/allocation, a 
    requirement for a part in period t3 is met by consuming stock from period 
    t1 < t3, even though the part could have been built in period t3. Later, a
    requirement for the part arrives in period t2, where t1 <= t2 < t3, and
    now there is no more stock available and the part cannot be produced in 
    period t2 or earlier. With the old code, this requirement could not be met
    on time.

    This feature allows the period t2 requirement to use the period t1 
    stock previously allocated the period t3 requirement, and then produce in
    period t3 to re-meet the period t3 requirement.

    Needed by SCORPIO for DtP and ATP. The scenario arises in DtP, when the
    modeling of local versus long distance shipments results in drastically
    differing lead-times. It arises in ATP, when a demand from a lower priority
    class occurs in an earlier period than previously allocated demands in
    higher priority classes.

    Stock reallocation is invoked by setting the global boolean attribute
    "stockRealloc" to true.

---------------------------

2-22-00

[vector attributes]


    Replaced three scalar attributes by vector attributes: The scalar part
    attribute "buildAheadLimit" was replaced by the vector part attribute
    "buildAheadUB", the scalar demand attribute "buildAheadLimit" was replaced 
    by the vector demand attribute "buildAheadUB", and the scalar demand
    attribute "shipLateLimit" was replaced by the vector demand attribute
    "shipLateUB". This was done in an upward compatible way.

    In the part buildAheadLimit case, this was needed by SCORPIO in general, 
    because it uses variable length time periods. Specifically needed for Sony.
    The others were done for consistency.

---------------------------

1-27-00

[two-way multi-exec]
    Wish list item: [asap multi-exec]

    The "multiple execution periods" technique has been extended to include a
    new variant: "two-way multiple execution periods". This variant allows the
    multi-exec technique to consider the execution periods in either of two
    orders: No-Sooner-Than-Necessary or As-Soon-As-Possible, where the
    selection of the ordering to be used is determined in part by the 
    application and in part automatically. This allows resources to be consumed
    in a more consistent order.

    Needed by Scorpio for the SONY application.

---------------------------

[path counting]
    Changed the penalty function for penalized execution heuristic implosion /
    allocation from the previous "execVol" based penalty to the newly proposed 
    "path counting" penalty function. This was needed because the "execVol"
    function was too sensitive to things like yield, which caused the pen-exec
    technique to select routings considered undesirable by the user.

    Needed by SCORPIO for SONY.

---------------------------

Summer 99

[64 bit]
    Ported PRM to the AIX 4.3 / 64 bit platform. Since OSL is not available on
    this platform, this is be a heuristic only version. This port enables PRM
    (heuristic implosion) to be applied to problems that cause it to require
    more than 2G of memory.

    This was needed by SCORPIO for KEM and Semiconductor customers in general.

---------------------------

8-13-99

[penalized execution]
    Allows the user to specify an "execution penalty" (execPenalty) attribute 
    for each operation, which is a per unit penalty to be incurred when the 
    operation is executed. Whenever heuristic implosion / allocation tries to
    meet a demand, it attempts (heuristically) to do so in a way 
    that minimizes the total execution penalty. The purpose is to enable
    heuristic implosion to consume resources higher in the complete BOM
    structure before consuming those lower in the structure.

    This is needed for SCORPIO applications in which supplies of high level 
    subassemblies represent valuable inventory that should be used rather than
    building a product from its raw materials. This capability was considered
    critically important for semiconductor customers.

---------------------------

7-1-99

[explosion cutoff]

    A new global float input attribute was been added: expCutoff. This
    attribute specifies the minimum required value of yieldRate * prodRate in
    order for PRM to consider using a BOP entry in an explosion.

    This user control was needed for the SCE "smart explode" capability for MD.

---------------------------

6-22-99

[lot-size tolerance]

    A new global float input attribute was been added: lotSizeTol. This
    attribute gives the user the ability to control the numerical tolerance that
    PRM uses when computing lot-size feasible execVols. 
    
    Some change to the lot-size tolerance was needed for a situation perceived 
    by a SCORPIO customer who noticed that heuristic implosion was producing
    one more unit than required for some parts and periods. Perceiving that
    it was unlikely that one tolerance would be appropriate for all 
    applications, we decided to give the application developer control over the
    tolerance.

---------------------------

6-9-99

[removal of local build-ahead and local multi-exec]

    The local build-ahead (LBA) and local multiple execution periods (LMEP) 
    techniques were removed from the code. They have been replaced by, 
    respectively, the NSTN build-ahead and global multiple execution periods
    (GMEP) techniques. The NSTN and GMEP techniques are generally more robust
    (less likely to produce surprisingly bad results) than the LBA and LMEP
    techniques, because they employ global information, while the LBA and LMEP
    techniques rely on local information. These local techniques were removed
    in order to simply the documentation, the user's concept of PRM, and the 
    internal code. Upward compatibility has been maintained by causing
    requests for the removed local techniques to be interpreted as requests for
    the global techniques.

---------------------------

4-21-99

[global multiple execution periods] 
    In cases where the offsets/impactPeriods of a BOP entry map more than
    one execution period to the same production period, enhanced heuristic
    implosion/allocation to (optionally) consider using all of the execution
    periods corresponding to a given production period instead of just one.
    For a given operation, the alternative execution periods would be used 
    in order to accommodate constraints that apply anywhere below the
    operation in question (i.e., "global" constraints).
    
    This case arises in SCORPIO models, because they use BOP entry offsets
    to model lead time and they use variable length periods. The ability
    to deal with this case was considered very important (equivalent to 
    "trouble") by SCORPIO's customers.

---------------------------

2-15-99

[nstn build-ahead]
    Wish List item: [alap build-ahead]
    Enabled heuristic implosion and allocation to do global build-ahead of any
    (material) part on an NSTN (No-Sooner-Than-Necessary) basis, similar to ASAP
    build-ahead, but reversing the prioritization of the build periods. Since 
    this technique can be applied to any material part, it's much more general 
    than build-ahead by demand. Since it considers global constraints, it's
    more robust than local build-ahead.

    This technique was proposed as a solution to a problem the SCORPIO 
    team found in which ordinary local build-ahead prevented the heuristic
    from properly using a substitute. NSTN build-ahead will not tend to 
    have this kind of problem.

---------------------------

12-18-98

[build ahead limit]
    A new integer input attribute for parts has been added: "buildAheadLimit". 
    When heuristic implosion or allocation is doing build-ahead on the part, 
    the part will not be built more than buildAheadLimit periods earlier than 
    it is needed. This attribute applies to the following forms of build-ahead:

    * ASAP Build-Ahead
    * Local Build-Ahead
    
    This was a preliminary step of the [alap build-ahead] wish list item.
    When ALAP build ahead is implemented, buildAheadLimit will apply to it as 
    well.

---------------------------

12-15-98

[explosion period gaps]
    This allows MRP, FSS, and heuristic implosion to build in an earlier 
    period, if there is a gap in the set of periods eligible for the explosion
    of a part. This replaces the [impact period gaps] feature and is more
    robust. The new behavior now happens automatically.

    This was needed for SCE for MD, and the increased robustness should be
    beneficial for the SCORPIO applications.

---------------------------

12-1-98

[full explode]
    This was not actually an update to the PRM code; it's just a new way of
    using the existing code. Determined how to use PRM-MRP to do a full
    explosion MRP. The technique critically depends on [impact period gaps].

    This was needed for SCORPIO for Melco, Omron, Cannon, and Cassio.

---------------------------

11-18-98

[impact period gaps]
    Allowed MRP, FSS, and heuristic implosion to build in an earlier period, if
    there is a gap in the set of impact periods for a BOP entry. The new
    behavior now happens automatically.

    This was needed for SCORPIO for Melco, Omron, Cannon, and Cassio.

---------------------------

11-16-98

[removal of intense local build-ahead]
    De-implemented intense local build-ahead. It was unreliable and has been
    replaced by ASAP build-ahead.

---------------------------

11-6-98

[asap build-ahead]
    Wish list item: [hybrid build-ahead].
    Added the "ASAP build-ahead" capability to heuristic implosion and 
    allocation. For any material part, if the buildAsap attribute is TRUE, 
    the heuristic will try to build the part in the earliest possible 
    period, based on global constraints. Since this technique can be applied to 
    any material part, it is much more general than intense local build-ahead,
    which only works on bottom-level products and much more general than
    preferential global build-ahead, which only applies to production to meet
    external demand directly. (ASAP build-ahead is a new form of global
    build-ahead.)

    This feature was needed for SCORPIO for Melco and Omron (these customers
    have been waiting for it) and for semiconductor applications in general.

---------------------------

9-3-98

[local multiple execution periods] 
    In cases where the offsets/impactPeriods of a BOP entry map more than
    one execution period to the same production period, heuristic
    implosion/allocation can now (optionally) consider using all of the 
    execution periods corresponding to a given production period instead of
    just one. For a given operation, the alternative execution periods would be 
    used only in order to accommodate constraints that apply to that operation 
    and its BOM (i.e., "local" constraints).
    
    This case arises in SCORPIO models, because they use BOP entry offsets
    to model lead time and they use variable length periods. The ability
    to deal with this case is considered very important (equivalent to 
    "trouble") by SCORPIO's customers. What's really needed is [global 
    multiple execution periods] (see wish list), but [local multiple execution
    periods] was implemented first, because a solution was needed as soon
    as possible.

---------------------------

7-24-98

[BOP entry impact periods]
    In a case where BOP entries had offsets that varied by period (representing
    variable length periods), PRM was computing impactPeriods that lead to 
    cumulative lead times that were far away from the actual cumulative lead
    times. I modified the computation of impactPeriods for BOP entries offsets
    that vary by period, and now the impactPeriods lead to very accurate 
    cumulative lead times for the case in question.

    This was needed for SCORPIO for Mitsubishi ASAP.
 
---------------------------

7-21-98

[preferential global build-ahead]

    Allows global build-ahead (to satisfy external demand for a part) to be
    done "preferentially", i.e., build ahead as much as possible, rather than
    as little as possible, which the default global build-ahead behavior.
    Can be requested separately for each demand.

    Helpful for SCORPIO for Melco and Omron and for semiconductor applications
    in general. What they really need is the ability to do preferential
    build-ahead with global considerations independently on each part in the
    complete BOM (as in [early execution]), but Toguchi thinks they can use 
    this feature as an interim solution.

---------------------------

5-27-98

[deletion of data objects]

    Allows any PRM object (part, BOM entry, etc.) to be deleted.
    Deletion is done in two phases: "selection", in which the user selects
    the objects to be deleted and "purge", in which PRM deletes the selected
    objects. During the purge PRM also deletes any object that has one or more
    prerequisites that are being deleted, e.g., if an operation is being
    deleted, its BOM entries will also be deleted.

    Very useful for SCE and other apps. JP has said PRM wouldn't be complete
    without it.

---------------------------

3-10-98

[multiRoute memory]

    Prior to this update, tests with real data indicated that heuristic
    implosion using multiRoute could consume much more memory than without
    multiRoute, in one case, more than 3 times as much. This update greatly
    reduced the memory consumption of multiRoute, typically to within a few
    percent of the heuristic without multiRoute.

    This was needed quite seriously for Omron, for Dama, and for the general
    ability to apply multiRoute.

---------------------------

2-25-98

[mrp sub net]

    Allowed MRP and FSS optionally to use existing supplies of the parts
    consumed by a substitute before exploding through the main BOM entry,
    in a manner similar to heuristic implosion. A new boolean input attribute
    for substitutes, "mrpNetAllowed" controls this capability. A new output
    attribute for substitutes, "mrpSubVol" indicates the resulting
    substitution volumes.

---------------------------

2-10-98

[exp net controls update]

   Replaced expNetPref for substitute BOM entries with expNetAversion, which
      has the reverse meaning.

   Replaced expPref for BOP entries with expAversion, which has the reverse
      meaning.

   These reversals were requested by the SCE folks.

---------------------------

2-6-98

[intense local build-ahead]

    (Formerly known as [early capacity].)
    Made heuristic implosion have an option to preferentially use capacity in
    earlier periods rather than later periods, so that capacity in later periods
    will be left available for unforeseen demands. This was done by adding
    a new part boolean input attribute "intenseLBA". Setting the attribute to
    TRUE and setting localBuildAhead to TRUE causes heuristic implosion and
    allocation to do local build-ahead for the part starting with the earliest
    possible period.

---------------------------

1-30-98

[belowList]
    Made PRM's internal below list into an attribute accessible through the
    API.

---------------------------

1-23-98

[full explode]
    Optionally allowed MRP to explode all the way to the bottom of the
    multi-level BOM in cases where this would theoretically put requirements in
    negative periods. In such cases, just put the requirements in period 0.

    This was done by implementing the "truncOffsets" (truncated offsets)
    attribute, which, when TRUE, causes any offset[t] > t to be interpreted as
    if offset[t] = t, implying impact in period 0. When witMrp is invoked in
    this mode, the result is a full explode.

---------------------------

1-14-98

[double]
    Made PRM use double precision for all calculations that seemed potentially
    susceptible to round-off problems.

---------------------------

11-11-97

[earliest off]
    The "earliest" flag in the heuristic can sometimes cause it to miss
    significant opportunities to meet demands, when there is co-production.
    The "skipFailures" attribute was added, which allows the user to turn
    this behavior off.

---------------------------

11-5-97

[exp net controls]

   Several new input attributes have been add that give the user more control
   over the way explosions and netting are performed by those actions in PRM
   that use explosion and netting logic (heuristic implosion and allocation,
   PRM-MRP, and FSS). The new attributes are:

   expAllowed (Substitute BOM entries)
      Determines whether or not explosion can be done at the substitute.

   netAllowed (Substitute BOM entries)
      Determines whether or not netting can be done at the substitute.

   expAllowed (BOP entries)
      Determines whether or not explosion can be done at the BOP entry.

   expNetPref (Substitute BOM entries)
      Preferability of exploding or netting at the substitute vs. other
         substitutes for the same BOM entry.

   expPref (BOP entries)
      Preferability of exploding at the BOP entry vs. other BOP entries
      producing the same part.

---------------------------

11-5-97

[multi route]

   (Formerly know as [full sub alt].)

   Heuristic implosion and allocation have been enhanced to optionally allow
   the following:

   * Parts can be built in order to be used as substitutes.
   * Multiple BOP entries can be used in order to produce the same part.

   This new capability is called the "multiple routes technique". A new global
   input data attribute "multiRoute" has been added that controls whether or not
   the multiple routes technique is to be used.

---------------------------

7-17-97

[sub offsets]

   Added two new attributes: an offset attribute for substitutes and
   and a global boolean attribute, independentOffsets. The offset attribute for
   substitutes has the same meaning as the offset attribute for BOM entries.
   The independentOffsets attribute determines whether or not the offset at
   tribute for a substitute can be set independently of the offset attribute
   for the corresponding BOM entry.  SCE needed this for some present and future
   modeling. There was an aspect of SCE that was considered to be a bug,
   because it couldn't set substitute offsets independently.

---------------------------

6-12-97

[residualVol]

   Added part output attributes residualVol and mrpResidualVol. These attributes
   are similar to the pre-existing attributes excessVol and mrpExcessVol. SCE'S
   roll-over heuristic was implemented as an iterative use of heuristic implosion
   using the excessVol from one iteration as the supplyVol in the next. This
   turned out to unsatisfactory, because excessVol counts excess supply of the
   part, but not excess production, and so excess production due to lot-sizing
   was being lost. Production due to co-products is another important case in
   which excess production would be lost. The SCE team considered this to be a
   very serious problem and needed a solution as soon as possible. The use of
   residualVol, which includes both excess supply and excess production, solves
   this problem. mrpResidualVol, which is the like residualVol, but in the MRP
   context, was also needed by SCE.

---------------------------

5-27-97

[creation order]

   Modified witWriteData and witCopyData so that they caused the objects of
   a copied WitRun to be created in the same order in which they were created
   in the original WitRun. Among other things, this increased our ability to
   replicate user problems/bugs with PRM, by having the user store their
   PRM problem in a data file that we can use. The modification enabled
   this kind of replication to work in cases where it didn't work previously.

---------------------------

5-12-97

[mand split]
    An option for mandatory use of heuristic implosion's demand-splitting
    logic, even when not needed for equitable allocation. This would be
    helpful for some modeling tricks proposed for SCE, especially
    binning/sorting in semiconductor mfg.

    Very easy.

    ---

    Really just a finishing touch on a recent development.

---------------------------

4-29-97

[exp bop period]
    Have PRM's automatic choice of the explosion bopEntry depend on the
    period, so explosions in late periods could be along different bopEntries
    than in early periods.

    Considered essential for the next release of SCE, 6/6/97.

    Moderately easy.

    ---

    Moderately easy, and essential, with a deadline.

---------------------------

4-10-97

[preproc no parts]
   Allow preprocessing of a problem that has no parts.

   Needed for a use of witCopyData.

   Easy.

---------------------------

4-9-97

[float yield]
   Yield/fallout defined as floats instead of ints.
   Needed for Japanese external customers.
   It would be nice to have this for Toguchi's demo to Sharp in April.

   Easy. Some upward compatibility issues, but JP & I have worked out
   an acceptable solution.

   ---

   Quick and nice for Toguchi's demo.
